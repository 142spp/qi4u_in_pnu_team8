# 양자 컴퓨팅 기반 시간표 최적화 웹 서비스 (팀 8) - 개발 요약

본 문서는 현재까지 진행된 전체 시스템 구조 개선 및 프론트엔드/백엔드 UI/UX 작업 내용을 요약합니다.
(※ 양자 어닐링 모델링 및 목적 함수(Objective Function)의 코어 로직은 다른 팀원에 의해 별도 진행 중이므로 제외됨)

---

## 1. 아키텍처 및 백엔드 비동기 연동
*   **비동기 Task Queue 연동**: 프론트엔드에서 `/api/optimize` 호출 시, 백엔드 최적화 코드가 FastAPI 메인 스레드를 블로킹하지 않도록 `BackgroundTasks` 방식으로 전환 
*   **상태 폴링 (Polling)**: 클라이언트(프론트엔드)에서는 발급받은 `task_id`를 기반으로 백엔드에 지속적(1초 간격)으로 폴링하여, 연산 상태(PENDING, PROCESSING, SUCCESS, FAILURE)를 확인하도록 구현
*   **결과 수신 구조**: 연산이 성공적으로 완료되면 백엔드의 `taskStatus.result.schedule` 데이터를 반환받아, 즉각적으로 프론트엔드의 최적화 시간표 스토어에 덮어씌움

## 2. 프론트엔드 레이아웃 및 테마 개선
*   **2단 컴포넌트 레이아웃 분리**: 사용자의 시선 분산을 막기 위해 화면을 좌/우로 명확 분리 (`md:col-span-4` / `md:col-span-8`)
    - **좌측 패널**: 강의 검색창, 강의 목록(스크롤 기능), 목표 학점 입력란 및 최적화 실행(Run Quantum Optimization) 버튼 배치
    - **우측 패널**: 넓은 5일 7시간(또는 그 이상)의 달력/그리드형 메인 시간표 영역 배치
*   **단색(무채색) 기반 파스텔 톤 테마 적용**: 전반적인 컴포넌트 색상을 흰색/검은색 위주의 무채색(Achromatic)으로 통일하고, 포인트 컬러(Primary)를 살구/피치톤(`FDC3A1`) 한 가지로만 제한하여 깔끔한 모던 UI 완성

## 3. 메인 시간표 (TimetableView) 그리드 구현
*   **시간 포맷 정규식 파서 (`timeParser.ts`) 구현**: 각 강의의 다양한 시간/장소 문자열(예: `수 13:30-15:30`, `금 09:00(50)(외부)` 등)을 파싱하여 (시작 분, 종료 분, 요일 인덱스) 형태의 객체 배열로 변환하는 유틸리티 도입
*   **절대 좌표(Absolute) 기반 블럭 달력**: 리스트형이 아닌 시간대별로 쪼개진 그리드 뷰 구현
    - 월~금 5일치 열(Column) 구성 (08:00 ~ 20:00 까지 상하단 여유 공간 부여)
    - 시간 파서를 이용해 각 블록의 상단 위치(top)와 길이(height) 계산 후 그리드 상에 예쁜 둥근 블럭 형태로 절대배치 진행

## 4. 강의 검색 시스템 (LectureList) 최적화 및 UI/UX 정리
*   **리스트 플랫(Flat) 디자인 적용**: 4,000개가 넘는 항목이 부담스럽지 않도록, 각각의 아이템을 박스 형태가 아니라 깔끔한 분리선으로 나눠놓은 리스트 형태로 출력 변경
*   **성능 최적화 (Debounce & 제한 렌더링)**:
    - 사용자가 검색어를 타이핑할 때마다 DOM 리렌더링이 일어나 화면이 끊기는(Lag) 현상을 방지하고자 검색 입력 후 `300ms`의 디바운스 대기시간 도입
    - 필터링 조건을 복잡하게 두지 않고 직관적으로 **강의명(name), 강의코드(number)** 만으로 빠르게 찾도록 단순화
    - 최대 4,000개의 DOM 생성을 막기 위해 리스트 렌더에 `slice(0, 100)`을 적용, 최소한의 아이템만 브라우저 메모리에 올리는 가상화 대체 기법 사용
*   **목표 학점 입력 UI 추가**: 상단에 목표 이수 학점을 조정/입력할 수 있는 `Target Credits` 입력칸 구성. 입력값은 `useLectureStore`의 상태로 저장되어 최적화 `/optimize` Payload 에 담겨 백엔드로 전송되도록 준비 완료.

---

**향후 연결 지점**: 백엔드에서 `target_credits` 등의 조건을 수신하는 목적 함수가 완성되면, 본 요약의 1번 부분에 이어서 정상적으로 최적화 연동 테스트가 가능해집니다.
